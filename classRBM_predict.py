import os
from time import time
import numpy as np
import pickle
from rbm import RestrictedBoltzmannMachine as RBM, Joint as jRBM, BinomialRestrictedBoltzmannMachine as rbmb
from data import *
from sklearn.metrics import confusion_matrix, classification_report

def read_vectorized_features(data_dir, subset=None, norm=False,feature_version=2):
    """
    Read vectorized features into memory mapped numpy arrays
    """
    if subset is not None and subset not in ["train", "test"]:
        return None
    
    ndim = 2381 # default feature version2
    X_train = None
    y_train = None
    X_test = None
    y_test = None

    if subset is None or subset == "train":
        if (norm==False):
            X_train_path = os.path.join(data_dir, "X_train.dat")
            y_train_path = os.path.join(data_dir, "y_train.dat")
        else:
            X_train_path = os.path.join(data_dir, "X_train_norm.dat")
            y_train_path = os.path.join(data_dir, "y_train_norm.dat")
        y_train = np.memmap(y_train_path, dtype=np.float32, mode="r")
        N = y_train.shape[0]
        X_train = np.memmap(X_train_path, dtype=np.float32, mode="r", shape=(N, ndim))
        # print("X train shape: ", X_train.shape)
        # print("Y train shape: ", y_train.shape)
        if subset == "train":
            return X_train, y_train

    if subset is None or subset == "test":
        if (norm==False):
            X_test_path = os.path.join(data_dir, "X_test.dat")
            y_test_path = os.path.join(data_dir, "y_test.dat")
        else:
            X_test_path = os.path.join(data_dir, "X_test_norm.dat")
            y_test_path = os.path.join(data_dir, "y_test_norm.dat")
        y_test = np.memmap(y_test_path, dtype=np.float32, mode="r")
        N = y_test.shape[0]
        X_test = np.memmap(X_test_path, dtype=np.float32, mode="r", shape=(N, ndim))
        # print("X test shape: ", X_test.shape)
        # print("Y test shape: ", y_test.shape)
        if subset == "test":
            return X_test, y_test

    return X_train, y_train, X_test, y_test

if __name__=='__main__':
    data_path='C:\\Users\\Acer\\Desktop\\ember2018'
    trainX, trainY = read_vectorized_features(data_path,"train",True)
    testX, testY = read_vectorized_features(data_path,"test",True)
    test_size=3
    file_pickle=open("jRBM1_pickle.sav",'rb')
    jRBM1=pickle.load(file_pickle)
    # print "Check property of jRBM"
    # print "WeightsVH: ", jRBM1.WeightsVH
    # print "WeightsWTH: ", jRBM1.WeightsTH
    # print "Hidden Baises: ", jRBM1.HiddenBiases
    # print "VisibleBiases: ", jRBM1.VisibleBiases
    # print "Target Biases: ", jRBM1.TargetBiases
    print('Performing classification on test data...')
    t3=time()
    testX,testY=testX[:test_size,:],testY[:test_size]
    trainX, trainY=trainX[:test_size,:],trainY[:test_size]
    label = jRBM1.predict3(testX, testY)
    # label=jRBM1.predict3(trainX,trainY)
    predict_time = time()-t3

    counter = 0
    for i in range(len(label)):
        #print "Reconstrlabel is %f, original label is%f" % (label[i],testY[i]) 
        # if label[i] != testY[i]:
        print "label", i, ": ", label[i]
        if label[i].astype(int)!=testY[i].astype(int):
            #test_data = testX[i]
            counter +=1
            #print wrongly predicted
            #print "Reconstrlabel is %f, original label is%f" % (label[i],testY[i]) 
    err = counter / float(len(label))
    acc = 1 - err
    print "Classification error is %0.3f" % err
    print "Accuracy is %0.3f" % acc
    print "Confusion matrix:" 
    print  confusion_matrix(label.astype(int),testY.astype(int))
    print "Classification report:" 
    print  classification_report(label.astype(int),testY.astype(int))
    print "Prediction time is %0.3fs" % predict_time
    print "RBM predicted"